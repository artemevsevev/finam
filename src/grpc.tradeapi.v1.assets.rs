// This file is @generated by prost-build.
/// Запрос получения списка доступных бирж
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExchangesRequest {}
/// Список доступных бирж
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExchangesResponse {
    /// Информация о бирже
    #[prost(message, repeated, tag = "1")]
    pub exchanges: ::prost::alloc::vec::Vec<Exchange>,
}
/// Запрос получения списка доступных инструментов
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AssetsRequest {}
/// Список доступных инструментов
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetsResponse {
    /// Информация об инструменте
    #[prost(message, repeated, tag = "1")]
    pub assets: ::prost::alloc::vec::Vec<Asset>,
}
/// Запрос получения информации по конкретному инструменту
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAssetRequest {
    /// Символ инструмента
    #[prost(string, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
    /// ID аккаунта для которого будет подбираться информация по инструменту
    #[prost(string, tag = "2")]
    pub account_id: ::prost::alloc::string::String,
}
/// Список информации по конкретному инструменту
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAssetResponse {
    /// Код режима торгов
    #[prost(string, tag = "1")]
    pub board: ::prost::alloc::string::String,
    /// Идентификатор инструмента
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// Тикер инструмента
    #[prost(string, tag = "3")]
    pub ticker: ::prost::alloc::string::String,
    /// mic идентификатор биржи
    #[prost(string, tag = "4")]
    pub mic: ::prost::alloc::string::String,
    /// Isin идентификатор инструмента
    #[prost(string, tag = "5")]
    pub isin: ::prost::alloc::string::String,
    /// Тип инструмента
    #[prost(string, tag = "6")]
    pub r#type: ::prost::alloc::string::String,
    /// Наименование инструмента
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
    /// Кол-во десятичных знаков в цене
    #[prost(int32, tag = "10")]
    pub decimals: i32,
    /// Минимальный шаг цены. Для расчета финального ценового шага: min_step/(10ˆdecimals)
    #[prost(int64, tag = "11")]
    pub min_step: i64,
    /// Кол-во штук в лоте
    #[prost(message, optional, tag = "9")]
    pub lot_size: ::core::option::Option<
        super::super::super::super::google::r#type::Decimal,
    >,
    /// Дата экспирации фьючерса
    #[prost(message, optional, tag = "12")]
    pub expiration_date: ::core::option::Option<
        super::super::super::super::google::r#type::Date,
    >,
}
/// Запрос торговых параметров инструмента
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAssetParamsRequest {
    /// Символ инструмента
    #[prost(string, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
    /// ID аккаунта для которого будут подбираться торговые параметры
    #[prost(string, tag = "2")]
    pub account_id: ::prost::alloc::string::String,
}
/// Торговые параметры инструмента
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAssetParamsResponse {
    /// Символ инструмента
    #[prost(string, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
    /// ID аккаунта для которого подбираются торговые параметры
    #[prost(string, tag = "2")]
    pub account_id: ::prost::alloc::string::String,
    /// Доступны ли торговые операции
    #[prost(bool, tag = "3")]
    pub tradeable: bool,
    /// Доступны ли операции в Лонг
    #[prost(message, optional, tag = "4")]
    pub longable: ::core::option::Option<Longable>,
    /// Доступны ли операции в Шорт
    #[prost(message, optional, tag = "5")]
    pub shortable: ::core::option::Option<Shortable>,
    /// Ставка риска для операции в Лонг
    #[prost(message, optional, tag = "6")]
    pub long_risk_rate: ::core::option::Option<
        super::super::super::super::google::r#type::Decimal,
    >,
    /// Сумма обеспечения для поддержания позиции Лонг
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub long_collateral: ::core::option::Option<
        super::super::super::super::google::r#type::Money,
    >,
    /// Ставка риска для операции в Шорт
    #[prost(message, optional, tag = "8")]
    pub short_risk_rate: ::core::option::Option<
        super::super::super::super::google::r#type::Decimal,
    >,
    /// Сумма обеспечения для поддержания позиции Шорт
    #[deprecated]
    #[prost(message, optional, tag = "9")]
    pub short_collateral: ::core::option::Option<
        super::super::super::super::google::r#type::Money,
    >,
    /// Начальные требования, сколько на счету должно быть свободных денежных средств, чтобы открыть лонг позицию, для FORTS счетов равен биржевому ГО
    #[prost(message, optional, tag = "10")]
    pub long_initial_margin: ::core::option::Option<
        super::super::super::super::google::r#type::Money,
    >,
    /// Начальные требования, сколько на счету должно быть свободных денежных средств, чтобы открыть шорт позицию, для FORTS счетов равен биржевому ГО
    #[prost(message, optional, tag = "11")]
    pub short_initial_margin: ::core::option::Option<
        super::super::super::super::google::r#type::Money,
    >,
}
/// Запрос получения цепочки опционов
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OptionsChainRequest {
    /// Символ базового актива опциона
    #[prost(string, tag = "1")]
    pub underlying_symbol: ::prost::alloc::string::String,
}
/// Информация о цепочке опционов
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OptionsChainResponse {
    /// Символ базового актива опциона
    #[prost(string, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
    /// Информация об опционе
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<Option>,
}
/// Запрос получения расписания инструмента
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScheduleRequest {
    /// Символ инструмента
    #[prost(string, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
}
/// Расписание инструмента
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleResponse {
    /// Символ инструмента
    #[prost(string, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
    /// Сессии инструмента
    #[prost(message, repeated, tag = "2")]
    pub sessions: ::prost::alloc::vec::Vec<schedule_response::Sessions>,
}
/// Nested message and enum types in `ScheduleResponse`.
pub mod schedule_response {
    /// Сессии
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Sessions {
        /// Тип сессии
        #[prost(string, tag = "1")]
        pub r#type: ::prost::alloc::string::String,
        /// Интервал сессии
        #[prost(message, optional, tag = "2")]
        pub interval: ::core::option::Option<
            super::super::super::super::super::google::r#type::Interval,
        >,
    }
}
/// Запрос получения времени на сервере
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClockRequest {}
/// Время на сервере
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClockResponse {
    /// Метка времени
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
/// Информация о бирже
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Exchange {
    /// Идентификатор биржи mic
    #[prost(string, tag = "1")]
    pub mic: ::prost::alloc::string::String,
    /// Наименование биржи
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
/// Информация об инструменте
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Asset {
    /// Символ инструмента ticker@mic
    #[prost(string, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
    /// Идентификатор инструмента
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// Тикер инструмента
    #[prost(string, tag = "3")]
    pub ticker: ::prost::alloc::string::String,
    /// mic идентификатор биржи
    #[prost(string, tag = "4")]
    pub mic: ::prost::alloc::string::String,
    /// Isin идентификатор инструмента
    #[prost(string, tag = "5")]
    pub isin: ::prost::alloc::string::String,
    /// Тип инструмента
    #[prost(string, tag = "6")]
    pub r#type: ::prost::alloc::string::String,
    /// Наименование инструмента
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
}
/// Информация об опционе
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Option {
    /// Символ инструмента
    #[prost(string, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
    /// Тип инструмента
    #[prost(enumeration = "option::Type", tag = "2")]
    pub r#type: i32,
    /// Лот, количество базового актива в инструменте
    #[prost(message, optional, tag = "4")]
    pub contract_size: ::core::option::Option<
        super::super::super::super::google::r#type::Decimal,
    >,
    /// Дата старта торговли
    #[prost(message, optional, tag = "5")]
    pub trade_first_day: ::core::option::Option<
        super::super::super::super::google::r#type::Date,
    >,
    /// Дата окончания торговли
    #[prost(message, optional, tag = "6")]
    pub trade_last_day: ::core::option::Option<
        super::super::super::super::google::r#type::Date,
    >,
    /// Цена исполнения опциона
    #[prost(message, optional, tag = "7")]
    pub strike: ::core::option::Option<
        super::super::super::super::google::r#type::Decimal,
    >,
    /// Множитель опциона
    #[prost(message, optional, tag = "9")]
    pub multiplier: ::core::option::Option<
        super::super::super::super::google::r#type::Decimal,
    >,
    /// Дата начала экспирации
    #[prost(message, optional, tag = "10")]
    pub expiration_first_day: ::core::option::Option<
        super::super::super::super::google::r#type::Date,
    >,
    /// Дата окончания экспирации
    #[prost(message, optional, tag = "11")]
    pub expiration_last_day: ::core::option::Option<
        super::super::super::super::google::r#type::Date,
    >,
}
/// Nested message and enum types in `Option`.
pub mod option {
    /// Тип опциона
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Неопределенное значение
        Unspecified = 0,
        /// Колл
        Call = 1,
        /// Пут
        Put = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Call => "TYPE_CALL",
                Self::Put => "TYPE_PUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TYPE_CALL" => Some(Self::Call),
                "TYPE_PUT" => Some(Self::Put),
                _ => None,
            }
        }
    }
}
/// Доступны ли операции в Лонг
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Longable {
    /// Статус инструмента
    #[prost(enumeration = "longable::Status", tag = "1")]
    pub value: i32,
    /// Сколько дней действует запрет на операции в Лонг (если есть)
    #[prost(int32, tag = "2")]
    pub halted_days: i32,
}
/// Nested message and enum types in `Longable`.
pub mod longable {
    /// Статус
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Не доступен
        NotAvailable = 0,
        /// Доступен
        Available = 1,
        /// Запрещено на уровне счета
        AccountNotApproved = 2,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NotAvailable => "NOT_AVAILABLE",
                Self::Available => "AVAILABLE",
                Self::AccountNotApproved => "ACCOUNT_NOT_APPROVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOT_AVAILABLE" => Some(Self::NotAvailable),
                "AVAILABLE" => Some(Self::Available),
                "ACCOUNT_NOT_APPROVED" => Some(Self::AccountNotApproved),
                _ => None,
            }
        }
    }
}
/// Доступны ли операции в Шорт
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Shortable {
    /// Статус инструмента
    #[prost(enumeration = "shortable::Status", tag = "1")]
    pub value: i32,
    /// Сколько дней действует запрет на операции в Шорт (если есть)
    #[prost(int32, tag = "2")]
    pub halted_days: i32,
}
/// Nested message and enum types in `Shortable`.
pub mod shortable {
    /// Статус
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Не доступен
        NotAvailable = 0,
        /// Доступен
        Available = 1,
        /// Признак того, что бумага Hard To Borrow (если есть)
        Htb = 2,
        /// Запрещено на уровне счета
        AccountNotApproved = 3,
        /// Разрешено в составе стратегии
        AvailableStrategy = 4,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NotAvailable => "NOT_AVAILABLE",
                Self::Available => "AVAILABLE",
                Self::Htb => "HTB",
                Self::AccountNotApproved => "ACCOUNT_NOT_APPROVED",
                Self::AvailableStrategy => "AVAILABLE_STRATEGY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOT_AVAILABLE" => Some(Self::NotAvailable),
                "AVAILABLE" => Some(Self::Available),
                "HTB" => Some(Self::Htb),
                "ACCOUNT_NOT_APPROVED" => Some(Self::AccountNotApproved),
                "AVAILABLE_STRATEGY" => Some(Self::AvailableStrategy),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod assets_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Сервис счетов
    #[derive(Debug, Clone)]
    pub struct AssetsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AssetsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AssetsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AssetsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AssetsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Получение списка доступных бирж, названия и mic коды
        /// Пример HTTP запроса:
        /// GET /v1/exchanges
        /// Authorization: <token>
        pub async fn exchanges(
            &mut self,
            request: impl tonic::IntoRequest<super::ExchangesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExchangesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/grpc.tradeapi.v1.assets.AssetsService/Exchanges",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("grpc.tradeapi.v1.assets.AssetsService", "Exchanges"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Получение списка доступных инструментов, их описание
        /// Пример HTTP запроса:
        /// GET /v1/assets
        /// Authorization: <token>
        pub async fn assets(
            &mut self,
            request: impl tonic::IntoRequest<super::AssetsRequest>,
        ) -> std::result::Result<tonic::Response<super::AssetsResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/grpc.tradeapi.v1.assets.AssetsService/Assets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("grpc.tradeapi.v1.assets.AssetsService", "Assets"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Получение информации по конкретному инструменту
        /// Пример HTTP запроса:
        /// GET /v1/assets/SBER@MISX?account_id=1440399
        /// Authorization: <token>
        ///
        /// Параметры:
        ///
        /// * symbol - передается в URL пути
        /// * account_id - передаётся как query-параметр
        pub async fn get_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAssetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/grpc.tradeapi.v1.assets.AssetsService/GetAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("grpc.tradeapi.v1.assets.AssetsService", "GetAsset"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Получение торговых параметров по инструменту
        /// Пример HTTP запроса:
        /// GET /v1/assets/SBER@MISX/params?account_id=1440399
        /// Authorization: <token>
        ///
        /// Параметры:
        ///
        /// * symbol - передается в URL пути
        /// * account_id - передаётся как query-параметр
        pub async fn get_asset_params(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAssetParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAssetParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/grpc.tradeapi.v1.assets.AssetsService/GetAssetParams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "grpc.tradeapi.v1.assets.AssetsService",
                        "GetAssetParams",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Получение цепочки опционов для базового актива
        /// Пример HTTP запроса:
        /// GET /v1/assets/SBER@MISX/options
        /// Authorization: <token>
        pub async fn options_chain(
            &mut self,
            request: impl tonic::IntoRequest<super::OptionsChainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OptionsChainResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/grpc.tradeapi.v1.assets.AssetsService/OptionsChain",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "grpc.tradeapi.v1.assets.AssetsService",
                        "OptionsChain",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Получение расписания торгов для инструмента
        /// Пример HTTP запроса:
        /// GET /v1/assets/SBER@MISX/schedule
        /// Authorization: <token>
        pub async fn schedule(
            &mut self,
            request: impl tonic::IntoRequest<super::ScheduleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ScheduleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/grpc.tradeapi.v1.assets.AssetsService/Schedule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("grpc.tradeapi.v1.assets.AssetsService", "Schedule"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Получение времени на сервере
        /// Пример HTTP запроса:
        /// GET /v1/assets/clock
        /// Authorization: <token>
        pub async fn clock(
            &mut self,
            request: impl tonic::IntoRequest<super::ClockRequest>,
        ) -> std::result::Result<tonic::Response<super::ClockResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/grpc.tradeapi.v1.assets.AssetsService/Clock",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("grpc.tradeapi.v1.assets.AssetsService", "Clock"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
